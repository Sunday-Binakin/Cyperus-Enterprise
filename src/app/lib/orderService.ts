import { createClientComponentClient } from '@supabase/auth-helpers-nextjs';
import { toast } from 'sonner';

// Types
export interface ShippingAddress {
  full_name: string;
  phone: string;
  address_line_1: string;
  address_line_2?: string;
  city: string;
  state: string;
  postal_code?: string;
  country: string;
}

export interface OrderItem {
  product_id: string;
  product_name: string;
  product_image?: string;
  price: number;
  quantity: number;
  variant_info?: Record<string, any>;
}

export interface CreateOrderData {
  user_id?: string;
  session_id?: string;
  items: OrderItem[];
  shipping_address: ShippingAddress;
  billing_address?: ShippingAddress;
  payment_method: 'paystack' | 'cash' | 'bank_transfer';
  subtotal: number;
  shipping_fee: number;
  tax: number;
  discount?: number;
  notes?: string;
  estimated_delivery_date?: string;
}

export interface Order {
  id: string;
  order_number: string;
  status: 'pending' | 'confirmed' | 'processing' | 'shipped' | 'delivered' | 'cancelled' | 'refunded';
  payment_status: 'pending' | 'paid' | 'failed' | 'refunded';
  payment_reference?: string;
  subtotal: number;
  shipping_fee: number;
  tax: number;
  discount: number;
  total: number;
  currency: string;
  payment_method: string;
  shipping_address: ShippingAddress;
  billing_address?: ShippingAddress;
  notes?: string;
  estimated_delivery_date?: string;
  delivered_at?: string;
  created_at: string;
  updated_at: string;
  items?: OrderItem[];
  tracking_events?: TrackingEvent[];
  courier_info?: CourierInfo;
}

export interface TrackingEvent {
  id: string;
  status: string;
  description: string;
  location?: string;
  notes?: string;
  created_at: string;
}

export interface CourierInfo {
  id: string;
  courier_company: string;
  tracking_number?: string;
  contact_phone?: string;
  contact_email?: string;
  estimated_delivery?: string;
}

export interface CustomerAddress {
  id: string;
  full_name: string;
  phone: string;
  address_line_1: string;
  address_line_2?: string;
  city: string;
  state: string;
  postal_code?: string;
  country: string;
  is_default: boolean;
}

class OrderService {
  private supabase = createClientComponentClient();

  /**
   * Create a new order
   */
  async createOrder(orderData: CreateOrderData): Promise<Order> {
    try {
      const total = orderData.subtotal + orderData.shipping_fee + orderData.tax - (orderData.discount || 0);

      // Create the order
      const { data: order, error: orderError } = await this.supabase
        .from('orders')
        .insert({
          user_id: orderData.user_id,
          session_id: orderData.session_id,
          order_number: '', // Will be generated by trigger
          subtotal: orderData.subtotal,
          shipping_fee: orderData.shipping_fee,
          tax: orderData.tax,
          discount: orderData.discount || 0,
          total,
          payment_method: orderData.payment_method,
          shipping_address: orderData.shipping_address,
          billing_address: orderData.billing_address,
          notes: orderData.notes,
          estimated_delivery_date: orderData.estimated_delivery_date,
        })
        .select()
        .single();

      if (orderError) throw orderError;

      // Create order items
      const orderItems = orderData.items.map(item => ({
        order_id: order.id,
        product_id: item.product_id,
        product_name: item.product_name,
        product_image: item.product_image,
        price: item.price,
        quantity: item.quantity,
        total: item.price * item.quantity,
        variant_info: item.variant_info,
      }));

      const { error: itemsError } = await this.supabase
        .from('order_items')
        .insert(orderItems);

      if (itemsError) throw itemsError;

      // Create initial tracking event
      await this.addTrackingEvent(order.id, 'pending', 'Order placed and awaiting confirmation');

      return order;
    } catch (error) {
      console.error('Error creating order:', error);
      throw new Error('Failed to create order');
    }
  }

  /**
   * Get order by ID
   */
  async getOrder(orderId: string): Promise<Order | null> {
    try {
      const { data: order, error } = await this.supabase
        .from('orders')
        .select(`
          *,
          order_items (*),
          order_tracking_events (*),
          order_courier_info (*)
        `)
        .eq('id', orderId)
        .single();

      if (error) {
        if (error.code === 'PGRST116') return null; // Not found
        throw error;
      }

      return {
        ...order,
        items: order.order_items || [],
        tracking_events: order.order_tracking_events || [],
        courier_info: order.order_courier_info?.[0] || null,
      };
    } catch (error) {
      console.error('Error fetching order:', error);
      throw new Error('Failed to fetch order');
    }
  }

  /**
   * Get orders for a user
   */
  async getUserOrders(userId: string, page = 1, limit = 10): Promise<{ orders: Order[]; total: number }> {
    try {
      const offset = (page - 1) * limit;

      // Get total count
      const { count } = await this.supabase
        .from('orders')
        .select('*', { count: 'exact', head: true })
        .eq('user_id', userId);

      // Get orders
      const { data: orders, error } = await this.supabase
        .from('orders')
        .select(`
          *,
          order_items (*)
        `)
        .eq('user_id', userId)
        .order('created_at', { ascending: false })
        .range(offset, offset + limit - 1);

      if (error) throw error;

      return {
        orders: orders.map(order => ({
          ...order,
          items: order.order_items || [],
        })),
        total: count || 0,
      };
    } catch (error) {
      console.error('Error fetching user orders:', error);
      throw new Error('Failed to fetch orders');
    }
  }

  /**
   * Update order status
   */
  async updateOrderStatus(orderId: string, status: Order['status'], notes?: string): Promise<void> {
    try {
      const { error } = await this.supabase
        .from('orders')
        .update({ 
          status,
          ...(status === 'delivered' && { delivered_at: new Date().toISOString() })
        })
        .eq('id', orderId);

      if (error) throw error;

      // Add tracking event
      await this.addTrackingEvent(orderId, status, `Order status updated to ${status}`, notes);
    } catch (error) {
      console.error('Error updating order status:', error);
      throw new Error('Failed to update order status');
    }
  }

  /**
   * Update payment status
   */
  async updatePaymentStatus(
    orderId: string, 
    paymentStatus: Order['payment_status'], 
    paymentReference?: string
  ): Promise<void> {
    try {
      const { error } = await this.supabase
        .from('orders')
        .update({ 
          payment_status: paymentStatus,
          ...(paymentReference && { payment_reference: paymentReference }),
          ...(paymentStatus === 'paid' && { status: 'confirmed' })
        })
        .eq('id', orderId);

      if (error) throw error;

      if (paymentStatus === 'paid') {
        await this.addTrackingEvent(orderId, 'confirmed', 'Payment confirmed, order is being processed');
      }
    } catch (error) {
      console.error('Error updating payment status:', error);
      throw new Error('Failed to update payment status');
    }
  }

  /**
   * Add tracking event
   */
  async addTrackingEvent(
    orderId: string, 
    status: string, 
    description: string, 
    location?: string,
    notes?: string
  ): Promise<void> {
    try {
      const { error } = await this.supabase
        .from('order_tracking_events')
        .insert({
          order_id: orderId,
          status,
          description,
          location,
          notes,
        });

      if (error) throw error;
    } catch (error) {
      console.error('Error adding tracking event:', error);
      throw new Error('Failed to add tracking event');
    }
  }

  /**
   * Add or update courier information
   */
  async updateCourierInfo(orderId: string, courierInfo: Omit<CourierInfo, 'id'>): Promise<void> {
    try {
      const { error } = await this.supabase
        .from('order_courier_info')
        .upsert({
          order_id: orderId,
          ...courierInfo,
        });

      if (error) throw error;
    } catch (error) {
      console.error('Error updating courier info:', error);
      throw new Error('Failed to update courier information');
    }
  }

  /**
   * Customer Address Management
   */
  async getCustomerAddresses(userId: string): Promise<CustomerAddress[]> {
    try {
      const { data, error } = await this.supabase
        .from('customer_addresses')
        .select('*')
        .eq('user_id', userId)
        .order('is_default', { ascending: false })
        .order('created_at', { ascending: false });

      if (error) throw error;
      return data || [];
    } catch (error) {
      console.error('Error fetching customer addresses:', error);
      throw new Error('Failed to fetch addresses');
    }
  }

  async addCustomerAddress(userId: string, address: Omit<CustomerAddress, 'id'>): Promise<CustomerAddress> {
    try {
      // If this is set as default, unset other default addresses
      if (address.is_default) {
        await this.supabase
          .from('customer_addresses')
          .update({ is_default: false })
          .eq('user_id', userId);
      }

      const { data, error } = await this.supabase
        .from('customer_addresses')
        .insert({
          user_id: userId,
          ...address,
        })
        .select()
        .single();

      if (error) throw error;
      return data;
    } catch (error) {
      console.error('Error adding customer address:', error);
      throw new Error('Failed to add address');
    }
  }

  async updateCustomerAddress(addressId: string, updates: Partial<CustomerAddress>): Promise<void> {
    try {
      const { error } = await this.supabase
        .from('customer_addresses')
        .update(updates)
        .eq('id', addressId);

      if (error) throw error;
    } catch (error) {
      console.error('Error updating customer address:', error);
      throw new Error('Failed to update address');
    }
  }

  async deleteCustomerAddress(addressId: string): Promise<void> {
    try {
      const { error } = await this.supabase
        .from('customer_addresses')
        .delete()
        .eq('id', addressId);

      if (error) throw error;
    } catch (error) {
      console.error('Error deleting customer address:', error);
      throw new Error('Failed to delete address');
    }
  }

  /**
   * Cart Synchronization
   */
  async syncCartToSupabase(userId: string, cartItems: any[]): Promise<void> {
    try {
      // Clear existing cart items for this user
      await this.supabase
        .from('cart_items')
        .delete()
        .eq('user_id', userId);

      // Insert new cart items
      if (cartItems.length > 0) {
        const supabaseCartItems = cartItems.map(item => ({
          user_id: userId,
          product_id: item.id,
          product_name: item.name,
          product_image: item.image,
          price: item.price,
          quantity: item.quantity,
          variant_info: item.variant ? { variant: item.variant } : null,
        }));

        const { error } = await this.supabase
          .from('cart_items')
          .insert(supabaseCartItems);

        if (error) throw error;
      }
    } catch (error) {
      console.error('Error syncing cart to Supabase:', error);
      // Don't throw error for cart sync failures
    }
  }

  async getCartFromSupabase(userId: string): Promise<any[]> {
    try {
      const { data, error } = await this.supabase
        .from('cart_items')
        .select('*')
        .eq('user_id', userId);

      if (error) throw error;

      return (data || []).map(item => ({
        id: item.product_id,
        name: item.product_name,
        image: item.product_image,
        price: item.price,
        quantity: item.quantity,
        variant: item.variant_info?.variant,
      }));
    } catch (error) {
      console.error('Error fetching cart from Supabase:', error);
      return [];
    }
  }

  /**
   * Webhook handlers for Paystack
   */
  async handlePaystackWebhook(event: any): Promise<void> {
    try {
      switch (event.event) {
        case 'charge.success':
          await this.handlePaymentSuccess(event.data);
          break;
        case 'charge.failed':
          await this.handlePaymentFailed(event.data);
          break;
        default:
          console.log('Unhandled webhook event:', event.event);
      }
    } catch (error) {
      console.error('Error handling webhook:', error);
      throw error;
    }
  }

  private async handlePaymentSuccess(paymentData: any): Promise<void> {
    const orderId = paymentData.metadata?.order_id;
    if (!orderId) return;

    await this.updatePaymentStatus(orderId, 'paid', paymentData.reference);
    
    // Send confirmation email (implement with Supabase Edge Functions)
    // await this.sendOrderConfirmationEmail(orderId);
  }

  private async handlePaymentFailed(paymentData: any): Promise<void> {
    const orderId = paymentData.metadata?.order_id;
    if (!orderId) return;

    await this.updatePaymentStatus(orderId, 'failed', paymentData.reference);
  }

  /**
   * Email notifications (to be implemented with Supabase Edge Functions)
   */
  async sendOrderConfirmationEmail(orderId: string): Promise<void> {
    try {
      // TODO: Implement with Supabase Edge Functions
      console.log('Sending order confirmation email for order:', orderId);
    } catch (error) {
      console.error('Error sending confirmation email:', error);
    }
  }

  async sendShippingNotification(orderId: string): Promise<void> {
    try {
      // TODO: Implement with Supabase Edge Functions
      console.log('Sending shipping notification for order:', orderId);
    } catch (error) {
      console.error('Error sending shipping notification:', error);
    }
  }

  async sendDeliveryNotification(orderId: string): Promise<void> {
    try {
      // TODO: Implement with Supabase Edge Functions
      console.log('Sending delivery notification for order:', orderId);
    } catch (error) {
      console.error('Error sending delivery notification:', error);
    }
  }
}

// Export singleton instance
export const orderService = new OrderService();

// Utility functions
export const formatOrderStatus = (status: Order['status']): string => {
  switch (status) {
    case 'pending':
      return 'Pending';
    case 'confirmed':
      return 'Confirmed';
    case 'processing':
      return 'Processing';
    case 'shipped':
      return 'Shipped';
    case 'delivered':
      return 'Delivered';
    case 'cancelled':
      return 'Cancelled';
    case 'refunded':
      return 'Refunded';
    default:
      return 'Unknown';
  }
};

export const formatPaymentStatus = (status: Order['payment_status']): string => {
  switch (status) {
    case 'pending':
      return 'Pending';
    case 'paid':
      return 'Paid';
    case 'failed':
      return 'Failed';
    case 'refunded':
      return 'Refunded';
    default:
      return 'Unknown';
  }
};

export const getOrderStatusColor = (status: Order['status']): string => {
  switch (status) {
    case 'delivered':
      return 'text-green-500';
    case 'shipped':
      return 'text-blue-500';
    case 'processing':
      return 'text-yellow-500';
    case 'confirmed':
      return 'text-[#EFE554]';
    case 'cancelled':
    case 'refunded':
      return 'text-red-500';
    default:
      return 'text-gray-500';
  }
};

export default OrderService;
